from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    DateTime,
    create_engine,
    ForeignKey,
    LargeBinary,
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, relationship
from datetime import datetime
import os
import uuid
import random
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Get database URL from environment or use default
DATABASE_URL = os.getenv(
    "DATABASE_URL", "sqlite+aiosqlite:///./backend/data/nano_tournament.db"
)

# Ensure the data directory exists
os.makedirs(
    os.path.dirname(DATABASE_URL.replace("sqlite+aiosqlite:///", "")), exist_ok=True
)

engine = create_async_engine(DATABASE_URL, echo=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

Base = declarative_base()


def generate_session_id() -> str:
    """Generate a 6-digit session ID"""
    return f"{random.randint(100000, 999999)}"


class Session(Base):
    __tablename__ = "sessions"

    id = Column(String, primary_key=True, default=generate_session_id)
    player1_id = Column(String, ForeignKey("users.id"))
    player2_id = Column(String, ForeignKey("users.id"), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    status = Column(String, default="waiting")  # waiting/active/completed
    condition = Column(Text, nullable=True)  # Fight condition generated by LLM

    # Battle-related fields (since battle and session are the same)
    winner_user_id = Column(String, ForeignKey("users.id"), nullable=True)
    battle_script = Column(
        Text, nullable=True
    )  # LLM's detailed battle script for video generation
    battle_summary = Column(Text, nullable=True)  # LLM's battle description
    battle_video_url = Column(Text, nullable=True)  # URL to the generated battle video
    confrontation_image = Column(
        LargeBinary, nullable=True
    )  # Generated confrontation image
    completed_at = Column(DateTime, nullable=True)

    # Relationships
    characters = relationship("Character", back_populates="session")
    player1 = relationship("User", foreign_keys=[player1_id])
    player2 = relationship("User", foreign_keys=[player2_id])
    winner = relationship("User", foreign_keys=[winner_user_id])


class User(Base):
    __tablename__ = "users"

    id = Column(String, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    characters = relationship("Character", back_populates="user")


class Character(Base):
    __tablename__ = "characters"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    session_id = Column(String, ForeignKey("sessions.id"))
    user_id = Column(String, ForeignKey("users.id"))
    image_data = Column(LargeBinary)  # Store image as binary data
    prompt_used = Column(Text)
    generated_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    session = relationship("Session", back_populates="characters")
    user = relationship("User", back_populates="characters")


async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


async def get_db():
    """Dependency for getting async database session"""
    async with async_session() as session:
        try:
            yield session
        finally:
            await session.close()
